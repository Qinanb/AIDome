## 数据库文件

通过网盘分享的文件：scott.db

链接: https://pan.baidu.com/s/1eMQNiXJLVF8YMx6g1Z1NPA

 提取码: hqyj 

## 单表查询

select * from emp;  查询员工表的所有列
select ename from emp; 查询员工表的ename这一列
distinct 表示去掉重复行的数据
<,>,>=,<=,<>,=   分别为 小于，大于，大于等于，小于等于，不等于，等于
where 为限定查询
select * from emp where sal >1600 ;查询所有基本工资高于1600的雇员信息
between... and …   用于取值范围的查询，两个数是闭区间
in(条件) 判断一个数据是否包含在若干条件中
not in 则取反
select * from emp where empno in(8899，1234);查询雇员编号为8899，1234的雇员信息。
like 配合通配符进行模糊查询  _ 匹配任意一个字符  %匹配任意多个字符
select * from emp where ename like '_A%'; 查询所有姓名以字母 开头的雇员信息
is null 判断是否为空  is not null 判断是否不为空
and  与操作，需要所有条件都满足
or  或操作，所有条件满足一个
not 取反
order by 对结果排序  有asc 升序和desc降序两种方式
select * from emp order by sal desc,hiredate asc; 查询所有雇员的信息，按照基本工资从高到低排序，如果基本工资相同，则按照雇佣日期从早到晚排序。
   排序例：
       select ename,empno,job,sal*12 income from emp order by income desc;按照年薪排序
     年薪越高越靠前，        其中income：是 sal*12 这个计算列的别名（也叫列别名），作用是给
     年薪临时的计算列起一个简洁、易读的名字，方便后续引用（比如排序）；

#### 分页查询

使用limit 和 offset关键字进行分页查询，limit表示取多少结果，offset表示去掉前几条数据
分页查询公式
每页的数量 n 当前的页码m
select * from emp limit n offset (m-1)*n

 每页显示6条数据，查询第2页的内容。

SELECT * FROM emp LIMIT 3 OFFSET 12;

## 函数

#### 字符串函数

upper 字符串转大写  lower 字符串转小写

length 获取字符串的长度

substr（参1，参2，参3）截取  参1：要处理的字符串  参2：截取起点  参3：截取长度 可为空，表示截取到最后

trim  去掉字符串前后的空格

#### 数字函数

round（参1，参2） 四舍五入   参1：数字  参2：保留多少位小数 ，若为空则保留到整数位 

mod （参1，参2）  取模  参1:被除数  参2：除数   

abs   取绝对值

#### 日期函数

date time datetime     date:获取日期  time：获取时间  datetime：日期+时间

​     查询雇佣时间：select time（hiredate）from emp;

​     查询雇佣日期：select date（hiredate）from emp;

​     把'2025-01-01'转换成日期和时间格式 ：   SELECT DATETIME('2025-01-01');

​     获取当前时间数据 select datetime（'now','localtime'） 参2位时区，当前时区使用local time，默认为格林威  治时间

julianday 儒略日

​     求出每个雇员的姓名和雇佣的年数

​     -- 可以精确到天数

​     SELECT ename,(JULIANDAY('now')-JULIANDAY(hiredate))/365 FROM emp;

​     -- 默认精确到年数

​     SELECT ename,DATE('now')-hiredate FROM emp;

strftime （参1，参2） 参1：  ![](D:\KuaKe\AgAABf_pTgyxdFxyikxGMZg-8PABxj6E.png)

​                                       参2：要格式化的日期或参数

#### 空值函数

ifnull （参1，参2）参1：可能为null的数据或数据列  参2：如果null则替换的数值

注：在sql中任何数+null结果都为null

#### 统计函数

count 计数  sum 求和   avg 平均值   max 最大值  min 最小值

**【思考】COUNT(*)、COUNT(字段)、COUNT(DISTINCT 字段)的区别？**

​	count（*）： 统计查询结果的总行数

​	count（字段）：统计字段值不为null的行数

​	count（distinct 字段）：去重后再统计非null的行数



## 多表查询

#### 多表查询与内连接、外连接

例：同时统计emp和dept表的数据量

```sqlite
--外连接 SQL99
select count(*) from emp left join dept on emp.deptno=dept.deptno;
--内连接 SQL89
select count(*) from emp ,dept where emp.deptno=dept.deptno;
```

无论是外连接还是内连接都需要有消除笛卡尔积的过程，如on emp.deptno=dept.deptno和where emp.deptno=dept.deptno 

通过这两段代码的也可以发现内连接和外连接存在明显的区别：

内连接只保留两张表中匹配成功的步骤，相当于取交集，只要某条记录在其中一张表中没有匹配项就会被过滤掉

外连接以某一张表为’‘主表’‘，保留主表的所有记录，与另一张表上不匹配的字段显示null

外连接又细分为左外连接，右外连接，全外连接

注：在SQL99版本中内连接 inner join 可简写为join

| 连接类型 | 适用场景                               | 示例需求                                       |
| -------- | -------------------------------------- | ---------------------------------------------- |
| 内连接   | 只需要两张表的 “交集” 数据             | 查询 “有部门的员工” 及其所属部门               |
| 左外连接 | 需保留主表所有数据，即使另一张表无匹配 | 查询 “所有员工” 及其所属部门（含无部门的员工） |
| 右外连接 | 需保留从表所有数据，即使主表无匹配     | 查询 “所有部门” 及其下属员工（含无员工的部门） |
| 全外连接 | 需保留两张表的所有数据                 | 查询 “所有员工 + 所有部门” 的关联关系          |

#### 自连接

自连接指的是多表查询中的多张表都为同一张表

例：查询每个雇员的编号、姓名、职位和领导姓名

```sqlite
select e.empno,e.ename,e.job,m.ename from emp e left join emp m on e.mgr=m.empno; 
```

自连接关键是给同一张表取不同的别名，从而明确字段归属，避免歧义

#### 其他连接和写法

##### 交叉连接  

可以保留笛卡尔积

```sqlite
select * from emp corss join dept;
--相当于
select * from emp,dept;
```

##### 自然连接

自动找到关联字段消除笛卡尔积，这种连接方式属于内连接，且自动消除的笛卡尔积有时会不准

```sqlite
select * from emp natural join dept;
```

##### using

 可以使用using关键字制定等式关系的关联字段 ,这种方式也属于内连接

```sqlite
select * from emp join dept using(deptno);
```

#### 集合

可以把数据库查询结果看作是集合，可以进行集合的计算

##### 并集（不显示重复记录）

```sqlite
-- 查询部门20或者基本功工资大于1500的雇员信息（不显示重复记录）
select * from emp where deptno=20
union
select * from emo where sal>1500;
```

##### 并集（显示重复记录）

```sqlite
-- 查询部门20或者基本功工资大于1500的雇员信息（显示重复记录）
select * from emp where deptno=20
union all
select *from emp where sal>1500;
```

##### 交集

```sqlite
-- 查询部门20且基本工资大于1500的员工
select * from emp where deptno=20
intersect
select * from emp where sal>1500;
```

##### 差集

返回存在与第一个查询结果中但不存在于第二个查询结果中的记录

```sqlite
-- 查询部门20但基本工资不大于1500的员工
select * from emp where deptno=20
except
select * from emp where sal>1500;
```

## 分组统计

#### 分组前提

分组的前提是若干数据中存在形同的若干特征，且符合这些特征的数据量不全为1

#### 分组统计

分组统计语法格式为

![](D:\KuaKe\分组统计格式.png)

例：按照职位分组，统计出每个职位的平均工资、最高工资、最低工资和人数。

```sqlite
-- 建议把分组字段加在SELECT上
-- 绝大多数分组统计SELECT子句中除了分组字段外都是统计函数
SELECT job,AVG(sal),MAX(sal),MIN(sal),COUNT(empno) FROM emp GROUP BY job ;
```

#### 分组限制

##### 限制1

非分组字段不得出现在SELECT子句中

![](D:\KuaKe\限制1.png)

SQLite中不会报错，但数据对应错乱

##### 限制2

SELECT子句中使用嵌套的统计函数可能会报错

![](D:\KuaKe\限制2.png)

##### 限制3

WHERE子句中不得使用统计函数

![](D:\KuaKe\限制3.png)

例：查询出每个部门的名称、人数和平均工资

```sqlite
SELECT dname,COUNT(empno),AVG(sal) FROM dept LEFT JOIN emp ON dept.deptno=emp.deptno GROUP BY dname;
```

#### 综合案例

例：统计公司每个工资等级的人数和每个等级的平均工资。

```sqlite
SELECT grade,COUNT(empno),AVG(sal) FROM salgrade LEFT JOIN emp ON emp.sal BETWEEN losal AND hisal GROUP BY grade;
```

#### 分组后筛查

使用HAVING子句完成，语法格式如下：

![](D:\KuaKe\HAVING.png)

例：按照职位分组，统计出每个职位的平均工资，显示平均工资高于2000的职位信息。

```sqlite
SELECT job,AVG(sal) FROM emp  GROUP BY job HAVING AVG(sal) >2000;
```

**思考：WHERE 和HAVING 的区别？**

​	WHERE是在分组前使用，不能使用统计函数

​	HAVING子句必须结合GROUP BY子句一起出现，是在分组后的过滤，可以使用统计函数

例：统计出公司领取佣金和不领取佣金的人数与平均工资。

```sqlite
-- 使用UNION对两个统计结果进行拼接
SELECT '领取佣金',COUNT(empno),AVG(sal) FROM emp WHERE comm IS NOT NULL
UNION
SELECT '不领取佣金',COUNT(empno),AVG(sal) FROM emp WHERE comm IS NULL;
```

**为什么这使用UNION而不使用HAVING？**

​	这是统计两个互斥的群体，相当于：群体A：所有 `comm IS NOT NULL` 的员工    群体B：所有 `comm IS NULL` 的员工 ，这两个群体是基于同一字段（comm）的两种状态，而我们想要的结果是两个独立的统计结果，而不是按comm分组统计，所以此时可以使用UNION进行手动分组，接触HAVING的限制

















